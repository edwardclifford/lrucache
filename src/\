import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import java.util.Random;

/**
 * Code to test an <tt>LRUCache</tt> implementation.
 */
public class CacheTest {
    /**
     * Implements a DataProvider that can be asked for keys of value (0..4).
     */
    public static class TestDataProvider implements DataProvider<Integer, String> {

        private boolean _referenced = false;

        /**
         * Returns a string for a given integer key
         * @param key a value 0 through 4
         * @return a string for the value or null if no value was found
         */
        public String get (Integer key) {
            _referenced = true;
            switch (key) {
                case 0:
                    return "Value for key 0.";
                case 1:
                    return "Value for key 1.";
                case 2:
                    return "Value for key 2.";
                case 3:
                    return "Value for key 3.";
                case 4:
                    return "Value for key 4.";
            }
            return null;
        }

        /**
         * Allows the referenced flag to be reset
         */
        public void resetReferenced () {
            _referenced = false;
        }

        /**
         * Checks if the TestDataProvider was used by the cache.
         * @return true if referenced, false otherwise.
         */
        public boolean wasReferenced () {
            return _referenced;
        }
    }

    /**
     * Confirms that the TestDataProvider class returns what is expected.
     */
    @Test
    public void testTestDataProviderWorks() {
        DataProvider<Integer, String> provider = new TestDataProvider();
        String testValue = provider.get(0);
        assertTrue(testValue == "Value for key 0.");
    }
    
    /**
     * Confirms that the TestDataProvider class returns what is expected.
     */
    @Test
    public void testCacheSizeOne() {
        TestDataProvider provider = new TestDataProvider();
        Cache<Integer, String> cache = new LRUCache<Integer, String>(provider, 1);
        cache.get(0);
        assertTrue(provider.wasReferenced());
        provider.resetReferenced();
        String fromCache = cache.get(0);
        assertFalse(provider.wasReferenced());
        assertTrue(fromCache == "Value for key 0.");
    }

    @Test
    public void leastRecentlyUsedIsCorrect () {
        DataProvider<Integer,String> provider = null; // Need to instantiate an actual DataProvider
        Cache<Integer,String> cache = new LRUCache<Integer,String>(provider, 5);
    }

    @Test
    public void testRandom () {
        randomHelper(100);
    }
    
    /**
     * Impliments a data provider that returns the string of the key passed
     */
    public class EchoDataProvider implements DataProvider<Integer, String> {
        public int _timesReferenced = 0;
        public boolean _wasReferenced = false;

        public String get (Integer key) {
            _timesReferenced ++;
            _wasReferenced = true;
            return Integer.toString(key); 
        } 
    } 

    public void randomHelper (int size) {
        // Create provider and cache
        EchoDataProvider provider = new EchoDataProvider();
        Cache<Integer, String> cache = new LRUCache<Integer, String>(provider, size);
        // Start a loop to insert n pairs and track progress
        Integer[] history = new Integer[size * 10];
        Random rand = new Random();
        for (int i = 0; i < size * 10; i++) {
            int key = rand.nextInt(size);             
            cache.get(key);
            history[(size * 10) - i - 1] = key;
        }
        // Read from cache
        for (int i = 0; i < size * 10; i++) {
            int key = rand.nextInt(size);
            provider._wasReferenced = false;
            cache.get(history[i]);
            if (i < size) {
                assertFalse(provider._wasReferenced);
            }
            else {
                assertTrue(provider._wasReferenced);
            }
        }
        return;
    }
}
